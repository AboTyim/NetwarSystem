#!/usr/bin/python
import csv, json, pprint, os, random, re, sys, time, datetime
import redis, walrus, tweepy, configparser, ssl
import psutil, getpass, setproctitle, platform
from time import gmtime, strftime
from elasticsearch import Elasticsearch
from elasticsearch_dsl import Search
from elasticsearch.connection import create_ssl_context
from urllib3.exceptions import ProtocolError
import squish2, requests

#urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
requests.packages.urllib3.disable_warnings()

config = configparser.ConfigParser()
config.read(os.environ['HOME'] +'/.twitter')
max = 500
if(len(sys.argv) > 2):
	max = int(sys.argv[2])

try:
	auth = tweepy.OAuthHandler(config['API']['consumer_key'], config['API']['consumer_secret'])
	auth.set_access_token(config['API']['access_token_key'], config['API']['access_token_secret'])
	api = tweepy.API(auth)
	y = api.verify_credentials()
	print(getpass.getuser() + " " +  y.screen_name)
except tweepy.error.TweepError:
	print(sys.argv[1] + " " + config[API].account)
	exit(1)


try:
	ssl_context = create_ssl_context(cafile='/home/root-ca.pem')
	ssl_context.check_hostname = False
	ssl_context.verify_mode = ssl.CERT_NONE

	client = Elasticsearch('https://hp1.netwarsystem.com:9200', ssl_context=ssl_context, timeout=60, http_auth=("admin", "LongPassword2019"))
except:
	sys.exit()


client.indices.create(index='tw' + config['STREAM']['index'], ignore=400)
client.indices.create(index='tm' + config['STREAM']['index'], ignore=400)
client.indices.create(index='tu' + config['STREAM']['index'], ignore=400)
client.indices.create(index='tr' + config['STREAM']['index'], ignore=400)

class StreamApi(tweepy.StreamListener):
	def on_status(self, status):
		global twbod
		global tmbod
		global tubod
		global trbod
		global cnt
		status._json.pop('coordinates', None)
		status._json.pop('contributors', None)
		status._json.pop('is_quote_status', None)
		status._json.pop('in_reply_to_status_id', None)
		status._json.pop('favorite_count', None)
		status._json.pop('in_reply_to_screen_name', None)
		status._json.pop('in_reply_to_user_id', None)
		status._json.pop('retweet_count', None)
		status._json.pop('favorite', None)
		status._json.pop('favorited', None)
		status._json.pop('favorite_count', None)
		status._json.pop('in_reply_to_user_id_str', None)
		status._json.pop('possibly_sensitive', None)
		status._json.pop('in_reply_to_status_id_str', None)
		status._json.pop('quoted_status', None)
		status._json.pop('quoted_status_id', None)
		status._json.pop('quoted_status_id_str', None)
		status._json.pop('retweeted', None)
		#status._json.pop('retweeted_status', None)
		status._json.pop('retweets', None)
		status._json.pop('retweet', None)
		status._json.pop('user.profile_background_color', None)
		status._json.pop('user.profile_background_image_url', None)
		status._json.pop('user.profile_background_image_url_https', None)
		status._json.pop('user.profile_background_tile', None)
		status._json.pop('user.profile_banner_url', None)
		status._json.pop('user.profile_image_url', None)
		status._json.pop('user.profile_image_url_https', None)
		status._json.pop('user.profile_link_color', None)
		status._json.pop('user.profile_location', None)
		status._json.pop('user.profile_sidebar_border_color', None)
		status._json.pop('user.profile_sidebar_fill_color', None)
		status._json.pop('user.profile_text_color', None)
		status._json.pop('user.profile_use_background_image', None)
		status._json['source'] = re.sub("<.*?>", "",status._json['source'])
		status._json['source'] = re.sub("\"", "",status._json['source'])

		twbod = twbod + "{ \"index\" : { \"_index\" : \"tw" + config['STREAM']['index'] + "\", \"_type\" : \"tweets\", \"_id\" : \"" + status.id_str + "\"} }\n"
		twbod = twbod + json.dumps(status._json) + "\n"
		cnt = cnt + 1
		#print(status.user.screen_name + " " + str(status.created_at))
# end twbod type tweets
		if(len(status._json['entities']['user_mentions']) > 0):
			for derp in status._json['entities']['user_mentions']:
				tmbod = tmbod + "{ \"index\" : { \"_index\" : \"tm" + config['STREAM']['index'] + "\", \"_type\" : \"mention\" }\n"
				tmdict = {}
				tmdict['status.id_str'] = status.id_str
				tmdict['created_at'] = str(status.created_at)
				tmdict['user.screen_name'] = status.user.screen_name
				tmdict['user.id_str'] = status.user.id_str
				tmdict['mention.screen_name'] = derp['screen_name']
				tmdict['mention.id_str']      = derp['id_str']
				tmdict['status.text'] = status.text
				tmbod = tmbod + json.dumps(tmdict) + "\n"
				#print("TMBOD RIGHT HERE " + tmbod)
				cnt = cnt + 1
# end tmbod type mention
		tubod = tubod + "{ \"index\" : { \"_index\" : \"tu" + config['STREAM']['index'] + "\", \"_type\" : \"twid\", \"_id\" : \"" + status.user.id_str + "\" }\n"
		smuser = squish2.squishuser(status.user)
		tubod = tubod + json.dumps(smuser._json) + "\n"
		cnt = cnt + 1
# end tubod type twid
		try:
			status.retweeted_status
		except:
			cnt = cnt
		else:
			rtuser = squish2.squishuser(status.retweeted_status.user)
			#print(status.retweeted_status.user._json)
			#This is tracking accounts that he been RT'd. Should be added to user cache?
			tubod = tubod + "{ \"index\" : { \"_index\" : \"tu" + config['STREAM']['index'] + "\", \"_type\" : \"twid\", \"_id\" : \"" + status.retweeted_status.user.id_str + "\" }\n"
			tubod = tubod + json.dumps(rtuser._json) + "\n"
			cnt = cnt + 1
			#mentions stream here
			trbod = trbod + "{ \"index\" : { \"_index\" : \"tr" + config['STREAM']['index'] + "\", \"_type\" : \"retweet\", \"_id\" : \"" + status.id_str + "\" }\n"
			trdict = {}
			trdict['status.id_str'] = status.id_str
			trdict['created_at'] = str(status.created_at)
			trdict['user.screen_name'] = status.user.screen_name
			trdict['dest.screen_name'] = status.retweeted_status.user.screen_name
			trdict['dest.id_str']      = status.retweeted_status.id_str
			trdict['status.text'] = status.text
			trbod = trbod + json.dumps(trdict) + "\n"
			cnt = cnt + 1
			#print(trbod)
			#print("")
# end trbod type retweet
			if(cnt > max):
				client.bulk(index="tw" + config['STREAM']['index'],doc_type="tweets",body=twbod)
				client.bulk(index="tm" + config['STREAM']['index'],doc_type="mention",body=tmbod)
				client.bulk(index="tu" + config['STREAM']['index'],doc_type="twid",body=tubod)
				client.bulk(index="tr" + config['STREAM']['index'],doc_type="tweets",body=trbod)
				print("!@# !@# !@# BULK !@# !@# !@#")
				print(str(len(twbod)) + " " + str(len(tmbod)) + " " + str(len(tubod)) + " " + str(len(trbod)))

				twbod = ""
				tmbod = ""
				tubod = ""
				trbod = ""
				cnt = 0


def on_error(self, status):
	if status == 420:
		sys.stderr.write('Enhance Your Calm; The App Is Being Rate Limited For Making Too Many Requests')
		return True
	else:
		sys.stderr.write('Error {}n'.format(status))
		return True

	
streamer = tweepy.Stream(auth=auth, listener=StreamApi(), timeout=30)

tfile = open(sys.argv[1], 'r')
terms = []
for thing in tfile:
	terms.append(thing.rstrip())
print(terms)

while True:
	try:
		twbod = ""
		tmbod = ""
		tubod = ""
		trbod = ""
		cnt = 0
		streamer.filter(None, terms)
	except (ProtocolError, AttributeError):
		print("CAUGHT ERROR - CONTINUING")
		continue
