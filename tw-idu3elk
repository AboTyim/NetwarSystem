#!/usr/bin/python
# one shot bulk Twitter account recorder
import csv, json, os, random, re, sys, time, datetime
import urllib2, redis, tweepy
import psutil, getpass, setproctitle, platform
import logging, logging.handlers
from simpleconfigparser import simpleconfigparser
from bs4 import BeautifulSoup
from time import gmtime, strftime
from elasticsearch import Elasticsearch
from elasticsearch_dsl import Search
from walrus import *

def elog(scname,mesg):
        mydate = str(datetime.datetime.utcnow())
        ebod = "{ \"index\" : { \"_index\" : \"perflog\", \"_type\" : \"perfdata\"} }\n"
        ebod = ebod + "{\"host\" : \"" + platform.node() + "\", \"shell\" : \"" + getpass.getuser() + "\", \"screen_name\" : \"" 
        ebod = ebod + scname + "\", \"event\" : \"" + mesg + "\" , \"date\" : \"" + mydate + "\"}\n"
	#print(ebod)
        try:
                client.bulk(body=ebod)
        except(RuntimeError, TypeError, NameError):
                pass


def get_all_tweets(screen_name):
	cnt = 0
	bod = ""
	new_tweets = api.user_timeline(screen_name = screen_name,count=20)
	while(len(new_tweets) > 0):
		for tweet in new_tweets:
			cnt = cnt + 1
			print(str(tweet.id) + " " + screen_name + " " + str(cnt))
			bod = bod + "{ \"index\" : { \"_index\" : \"twpower10\", \"_type\" : \"tweets\" } }\n"
			tweet._json.pop('truncated', None)
			tweet._json.pop('contributors', None)
			tweet._json.pop('is_quote_status', None)
			tweet._json.pop('in_reply_to_status_id', None)
			tweet._json.pop('favorite_count', None)
			tweet._json.pop('in_reply_to_screen_name', None)
			tweet._json.pop('in_reply_to_user_id', None)
			tweet._json.pop('retweet_count', None)
			tweet._json.pop('favorite', None)
			tweet._json.pop('favorited', None)
			tweet._json.pop('favorite_count', None)
			tweet._json.pop('in_reply_to_user_id_str', None)
			tweet._json.pop('possibly_sensitive', None)
			tweet._json.pop('in_reply_to_status_id_str', None)
			tweet._json.pop('retweeted', None)
			tweet._json.pop('retweets', None)
			tweet._json.pop('retweet', None)
			tweet._json['source'] = re.sub("<.*?>", "",tweet._json['source'])
			tweet._json['source'] = re.sub("\"", "",tweet._json['source'])
			bod = bod + json.dumps(tweet._json) + "\n"
		try:
			client.bulk(index="twpower10",doc_type="tweets",body=bod)
		except (RuntimeError, TypeError, NameError):
			elog(screen_name, "failed bulk add " + str(len(bod)))
			pass
		bod = ""
		oldest = new_tweets[-1].id - 1
		#wasting 200 calls? How do this efficiently? Count tweets processed?
		new_tweets = api.user_timeline(screen_name = screen_name,count=810, max_id=tweet.id)
		if(oldest == new_tweets[-1].id - 1):
			new_tweets = []
		#elog("added " + screen_name + " " + str(cnt))

# get_all_tweets
def check_resources():
	# make sure prior instance has exited
	for p in psutil.process_iter(attrs=['name', 'username']):
        	if (p.info['username'] == getpass.getuser()) and (p.info['name'] == "work" +getpass.getuser()):
                	elog("FAIL", "already running")
			sys.exit()

	setproctitle.setproctitle("work" + getpass.getuser())

	i = 0
	while (i < 30):
		zcpu = psutil.cpu_percent(interval=None, percpu=False)
		zmem = psutil.virtual_memory()[2]
		if (zcpu < 75) and (zmem < 75):
			i = 60
		i = i + 2
		time.sleep(2)

	#i < 60, don't have resources
        if (i  < 60):
                print()
                elog("FAIL","zcpu " + str(zcpu) + " zmem " + str(zmem))
                sys.exit()
        else:
		print("")
                #elog(getpass.getuser(),"sufficient resources to run")

# check_resources

# main begin
config = simpleconfigparser()
config.read(os.environ['HOME'] +'/.twitter')

try:
	client = Elasticsearch()
except:
	sys.exit()

#ensure prior instance has finished, and CPU/MEM usage < 75%
check_resources()


auth = tweepy.OAuthHandler(config.API.consumer_key, config.API.consumer_secret)
auth.set_access_token(config.API.access_token_key, config.API.access_token_secret)
api = tweepy.API(auth)
my = api.verify_credentials()
listlim = api.rate_limit_status()[u'resources'][u'lists'][u'/lists/members'][u'remaining']
tweetlim = api.rate_limit_status()[u'resources'][u'statuses'][u'/statuses/user_timeline'][u'remaining']
elog("LIMITS"," tweetlim " + str(tweetlim) + " listlim " + str(listlim))

wal = Walrus(host='localhost', port=6379, db=0)
work = wal.Set(getpass.getuser() + "work")
nextacct = work.pop()
print(nextacct)
elog(nextacct," starting")
get_all_tweets(nextacct)
print("got all tweets")
try:
	y = api.get_user(nextacct)
	if y:
		twbod = "{ \"index\" : { \"_index\" : \"tupower10\", \"_type\" : \"twid\" }\n"
		twbod = twbod + json.dumps(y._json)
		client.bulk(index="tupower10",doc_type="twid",body=twbod)
		elog(nextacct," tulogging")

except (RuntimeError, TypeError, NameError):
	elog(nextacct, " tulogging failed")
	pass
print("logged " + nextacct)
